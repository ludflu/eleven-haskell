{-
   ElevenLabs API Documentation

   This is the documentation for the ElevenLabs API. You can use this API to use our service programmatically, this is done by using your xi-api-key. <br/> You can view your xi-api-key using the 'Profile' tab on https://beta.elevenlabs.io. Our API is experimental so all endpoints are subject to change.

   OpenAPI Version: 3.0.2
   ElevenLabs API Documentation API version: 1.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : ElevenLabsAPIDocumentation.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module ElevenLabsAPIDocumentation.Model where

import ElevenLabsAPIDocumentation.Core
import ElevenLabsAPIDocumentation.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Description
newtype Description = Description { unDescription :: Text } deriving (P.Eq, P.Show)

-- ** Files
newtype Files = Files { unFiles :: [FilePath] } deriving (P.Eq, P.Show)

-- ** HistoryItemId
newtype HistoryItemId = HistoryItemId { unHistoryItemId :: Text } deriving (P.Eq, P.Show)

-- ** Labels
newtype Labels = Labels { unLabels :: Text } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** OptimizeStreamingLatency
newtype OptimizeStreamingLatency = OptimizeStreamingLatency { unOptimizeStreamingLatency :: Int } deriving (P.Eq, P.Show)

-- ** PageSize
newtype PageSize = PageSize { unPageSize :: Int } deriving (P.Eq, P.Show)

-- ** SampleId
newtype SampleId = SampleId { unSampleId :: Text } deriving (P.Eq, P.Show)

-- ** StartAfterHistoryItemId
newtype StartAfterHistoryItemId = StartAfterHistoryItemId { unStartAfterHistoryItemId :: Text } deriving (P.Eq, P.Show)

-- ** VoiceId
newtype VoiceId = VoiceId { unVoiceId :: Text } deriving (P.Eq, P.Show)

-- ** WithSettings
newtype WithSettings = WithSettings { unWithSettings :: Bool } deriving (P.Eq, P.Show)

-- ** XiApiKey
newtype XiApiKey = XiApiKey { unXiApiKey :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AddVoiceResponseModel
-- | AddVoiceResponseModel
-- AddVoiceResponseModel
-- 
data AddVoiceResponseModel = AddVoiceResponseModel
  { addVoiceResponseModelVoiceId :: !(Text) -- ^ /Required/ "voice_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddVoiceResponseModel
instance A.FromJSON AddVoiceResponseModel where
  parseJSON = A.withObject "AddVoiceResponseModel" $ \o ->
    AddVoiceResponseModel
      <$> (o .:  "voice_id")

-- | ToJSON AddVoiceResponseModel
instance A.ToJSON AddVoiceResponseModel where
  toJSON AddVoiceResponseModel {..} =
   _omitNulls
      [ "voice_id" .= addVoiceResponseModelVoiceId
      ]


-- | Construct a value of type 'AddVoiceResponseModel' (by applying it's required fields, if any)
mkAddVoiceResponseModel
  :: Text -- ^ 'addVoiceResponseModelVoiceId' 
  -> AddVoiceResponseModel
mkAddVoiceResponseModel addVoiceResponseModelVoiceId =
  AddVoiceResponseModel
  { addVoiceResponseModelVoiceId
  }

-- ** BodyDownloadHistoryItemsV1HistoryDownloadPost
-- | BodyDownloadHistoryItemsV1HistoryDownloadPost
-- Body_Download_history_items_v1_history_download_post
-- 
data BodyDownloadHistoryItemsV1HistoryDownloadPost = BodyDownloadHistoryItemsV1HistoryDownloadPost
  { bodyDownloadHistoryItemsV1HistoryDownloadPostHistoryItemIds :: !([Text]) -- ^ /Required/ "history_item_ids" - A list of history items to download, you can get IDs of history items and other metadata using the GET https://api.elevenlabs.io/v1/history endpoint.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BodyDownloadHistoryItemsV1HistoryDownloadPost
instance A.FromJSON BodyDownloadHistoryItemsV1HistoryDownloadPost where
  parseJSON = A.withObject "BodyDownloadHistoryItemsV1HistoryDownloadPost" $ \o ->
    BodyDownloadHistoryItemsV1HistoryDownloadPost
      <$> (o .:  "history_item_ids")

-- | ToJSON BodyDownloadHistoryItemsV1HistoryDownloadPost
instance A.ToJSON BodyDownloadHistoryItemsV1HistoryDownloadPost where
  toJSON BodyDownloadHistoryItemsV1HistoryDownloadPost {..} =
   _omitNulls
      [ "history_item_ids" .= bodyDownloadHistoryItemsV1HistoryDownloadPostHistoryItemIds
      ]


-- | Construct a value of type 'BodyDownloadHistoryItemsV1HistoryDownloadPost' (by applying it's required fields, if any)
mkBodyDownloadHistoryItemsV1HistoryDownloadPost
  :: [Text] -- ^ 'bodyDownloadHistoryItemsV1HistoryDownloadPostHistoryItemIds': A list of history items to download, you can get IDs of history items and other metadata using the GET https://api.elevenlabs.io/v1/history endpoint.
  -> BodyDownloadHistoryItemsV1HistoryDownloadPost
mkBodyDownloadHistoryItemsV1HistoryDownloadPost bodyDownloadHistoryItemsV1HistoryDownloadPostHistoryItemIds =
  BodyDownloadHistoryItemsV1HistoryDownloadPost
  { bodyDownloadHistoryItemsV1HistoryDownloadPostHistoryItemIds
  }

-- ** BodyTextToSpeechV1TextToSpeechVoiceIdPost
-- | BodyTextToSpeechV1TextToSpeechVoiceIdPost
-- Body_Text_to_speech_v1_text_to_speech__voice_id__post
-- 
data BodyTextToSpeechV1TextToSpeechVoiceIdPost = BodyTextToSpeechV1TextToSpeechVoiceIdPost
  { bodyTextToSpeechV1TextToSpeechVoiceIdPostText :: !(Text) -- ^ /Required/ "text" - The text that will get converted into speech.
  , bodyTextToSpeechV1TextToSpeechVoiceIdPostModelId :: !(Maybe Text) -- ^ "model_id" - Identifier of the model that will be used, you can query them using GET /v1/models.
  , bodyTextToSpeechV1TextToSpeechVoiceIdPostVoiceSettings :: !(Maybe VoiceSettings) -- ^ "voice_settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BodyTextToSpeechV1TextToSpeechVoiceIdPost
instance A.FromJSON BodyTextToSpeechV1TextToSpeechVoiceIdPost where
  parseJSON = A.withObject "BodyTextToSpeechV1TextToSpeechVoiceIdPost" $ \o ->
    BodyTextToSpeechV1TextToSpeechVoiceIdPost
      <$> (o .:  "text")
      <*> (o .:? "model_id")
      <*> (o .:? "voice_settings")

-- | ToJSON BodyTextToSpeechV1TextToSpeechVoiceIdPost
instance A.ToJSON BodyTextToSpeechV1TextToSpeechVoiceIdPost where
  toJSON BodyTextToSpeechV1TextToSpeechVoiceIdPost {..} =
   _omitNulls
      [ "text" .= bodyTextToSpeechV1TextToSpeechVoiceIdPostText
      , "model_id" .= bodyTextToSpeechV1TextToSpeechVoiceIdPostModelId
      , "voice_settings" .= bodyTextToSpeechV1TextToSpeechVoiceIdPostVoiceSettings
      ]


-- | Construct a value of type 'BodyTextToSpeechV1TextToSpeechVoiceIdPost' (by applying it's required fields, if any)
mkBodyTextToSpeechV1TextToSpeechVoiceIdPost
  :: Text -- ^ 'bodyTextToSpeechV1TextToSpeechVoiceIdPostText': The text that will get converted into speech.
  -> BodyTextToSpeechV1TextToSpeechVoiceIdPost
mkBodyTextToSpeechV1TextToSpeechVoiceIdPost bodyTextToSpeechV1TextToSpeechVoiceIdPostText =
  BodyTextToSpeechV1TextToSpeechVoiceIdPost
  { bodyTextToSpeechV1TextToSpeechVoiceIdPostText
  , bodyTextToSpeechV1TextToSpeechVoiceIdPostModelId = Nothing
  , bodyTextToSpeechV1TextToSpeechVoiceIdPostVoiceSettings = Nothing
  }

-- ** BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost
-- | BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost
-- Body_Text_to_speech_v1_text_to_speech__voice_id__stream_post
-- 
data BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost = BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost
  { bodyTextToSpeechV1TextToSpeechVoiceIdStreamPostText :: !(Text) -- ^ /Required/ "text" - The text that will get converted into speech.
  , bodyTextToSpeechV1TextToSpeechVoiceIdStreamPostModelId :: !(Maybe Text) -- ^ "model_id" - Identifier of the model that will be used, you can query them using GET /v1/models.
  , bodyTextToSpeechV1TextToSpeechVoiceIdStreamPostVoiceSettings :: !(Maybe VoiceSettings) -- ^ "voice_settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost
instance A.FromJSON BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost where
  parseJSON = A.withObject "BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost" $ \o ->
    BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost
      <$> (o .:  "text")
      <*> (o .:? "model_id")
      <*> (o .:? "voice_settings")

-- | ToJSON BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost
instance A.ToJSON BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost where
  toJSON BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost {..} =
   _omitNulls
      [ "text" .= bodyTextToSpeechV1TextToSpeechVoiceIdStreamPostText
      , "model_id" .= bodyTextToSpeechV1TextToSpeechVoiceIdStreamPostModelId
      , "voice_settings" .= bodyTextToSpeechV1TextToSpeechVoiceIdStreamPostVoiceSettings
      ]


-- | Construct a value of type 'BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost' (by applying it's required fields, if any)
mkBodyTextToSpeechV1TextToSpeechVoiceIdStreamPost
  :: Text -- ^ 'bodyTextToSpeechV1TextToSpeechVoiceIdStreamPostText': The text that will get converted into speech.
  -> BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost
mkBodyTextToSpeechV1TextToSpeechVoiceIdStreamPost bodyTextToSpeechV1TextToSpeechVoiceIdStreamPostText =
  BodyTextToSpeechV1TextToSpeechVoiceIdStreamPost
  { bodyTextToSpeechV1TextToSpeechVoiceIdStreamPostText
  , bodyTextToSpeechV1TextToSpeechVoiceIdStreamPostModelId = Nothing
  , bodyTextToSpeechV1TextToSpeechVoiceIdStreamPostVoiceSettings = Nothing
  }

-- ** ExtendedSubscriptionResponseModel
-- | ExtendedSubscriptionResponseModel
-- ExtendedSubscriptionResponseModel
-- 
data ExtendedSubscriptionResponseModel = ExtendedSubscriptionResponseModel
  { extendedSubscriptionResponseModelTier :: !(Text) -- ^ /Required/ "tier"
  , extendedSubscriptionResponseModelCharacterCount :: !(Int) -- ^ /Required/ "character_count"
  , extendedSubscriptionResponseModelCharacterLimit :: !(Int) -- ^ /Required/ "character_limit"
  , extendedSubscriptionResponseModelCanExtendCharacterLimit :: !(Bool) -- ^ /Required/ "can_extend_character_limit"
  , extendedSubscriptionResponseModelAllowedToExtendCharacterLimit :: !(Bool) -- ^ /Required/ "allowed_to_extend_character_limit"
  , extendedSubscriptionResponseModelNextCharacterCountResetUnix :: !(Int) -- ^ /Required/ "next_character_count_reset_unix"
  , extendedSubscriptionResponseModelVoiceLimit :: !(Int) -- ^ /Required/ "voice_limit"
  , extendedSubscriptionResponseModelProfessionalVoiceLimit :: !(Int) -- ^ /Required/ "professional_voice_limit"
  , extendedSubscriptionResponseModelCanExtendVoiceLimit :: !(Bool) -- ^ /Required/ "can_extend_voice_limit"
  , extendedSubscriptionResponseModelCanUseInstantVoiceCloning :: !(Bool) -- ^ /Required/ "can_use_instant_voice_cloning"
  , extendedSubscriptionResponseModelCanUseProfessionalVoiceCloning :: !(Bool) -- ^ /Required/ "can_use_professional_voice_cloning"
  , extendedSubscriptionResponseModelCurrency :: !(E'Currency) -- ^ /Required/ "currency"
  , extendedSubscriptionResponseModelStatus :: !(E'Status) -- ^ /Required/ "status"
  , extendedSubscriptionResponseModelNextInvoice :: !(InvoiceResponseModel) -- ^ /Required/ "next_invoice"
  , extendedSubscriptionResponseModelHasOpenInvoices :: !(Bool) -- ^ /Required/ "has_open_invoices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtendedSubscriptionResponseModel
instance A.FromJSON ExtendedSubscriptionResponseModel where
  parseJSON = A.withObject "ExtendedSubscriptionResponseModel" $ \o ->
    ExtendedSubscriptionResponseModel
      <$> (o .:  "tier")
      <*> (o .:  "character_count")
      <*> (o .:  "character_limit")
      <*> (o .:  "can_extend_character_limit")
      <*> (o .:  "allowed_to_extend_character_limit")
      <*> (o .:  "next_character_count_reset_unix")
      <*> (o .:  "voice_limit")
      <*> (o .:  "professional_voice_limit")
      <*> (o .:  "can_extend_voice_limit")
      <*> (o .:  "can_use_instant_voice_cloning")
      <*> (o .:  "can_use_professional_voice_cloning")
      <*> (o .:  "currency")
      <*> (o .:  "status")
      <*> (o .:  "next_invoice")
      <*> (o .:  "has_open_invoices")

-- | ToJSON ExtendedSubscriptionResponseModel
instance A.ToJSON ExtendedSubscriptionResponseModel where
  toJSON ExtendedSubscriptionResponseModel {..} =
   _omitNulls
      [ "tier" .= extendedSubscriptionResponseModelTier
      , "character_count" .= extendedSubscriptionResponseModelCharacterCount
      , "character_limit" .= extendedSubscriptionResponseModelCharacterLimit
      , "can_extend_character_limit" .= extendedSubscriptionResponseModelCanExtendCharacterLimit
      , "allowed_to_extend_character_limit" .= extendedSubscriptionResponseModelAllowedToExtendCharacterLimit
      , "next_character_count_reset_unix" .= extendedSubscriptionResponseModelNextCharacterCountResetUnix
      , "voice_limit" .= extendedSubscriptionResponseModelVoiceLimit
      , "professional_voice_limit" .= extendedSubscriptionResponseModelProfessionalVoiceLimit
      , "can_extend_voice_limit" .= extendedSubscriptionResponseModelCanExtendVoiceLimit
      , "can_use_instant_voice_cloning" .= extendedSubscriptionResponseModelCanUseInstantVoiceCloning
      , "can_use_professional_voice_cloning" .= extendedSubscriptionResponseModelCanUseProfessionalVoiceCloning
      , "currency" .= extendedSubscriptionResponseModelCurrency
      , "status" .= extendedSubscriptionResponseModelStatus
      , "next_invoice" .= extendedSubscriptionResponseModelNextInvoice
      , "has_open_invoices" .= extendedSubscriptionResponseModelHasOpenInvoices
      ]


-- | Construct a value of type 'ExtendedSubscriptionResponseModel' (by applying it's required fields, if any)
mkExtendedSubscriptionResponseModel
  :: Text -- ^ 'extendedSubscriptionResponseModelTier' 
  -> Int -- ^ 'extendedSubscriptionResponseModelCharacterCount' 
  -> Int -- ^ 'extendedSubscriptionResponseModelCharacterLimit' 
  -> Bool -- ^ 'extendedSubscriptionResponseModelCanExtendCharacterLimit' 
  -> Bool -- ^ 'extendedSubscriptionResponseModelAllowedToExtendCharacterLimit' 
  -> Int -- ^ 'extendedSubscriptionResponseModelNextCharacterCountResetUnix' 
  -> Int -- ^ 'extendedSubscriptionResponseModelVoiceLimit' 
  -> Int -- ^ 'extendedSubscriptionResponseModelProfessionalVoiceLimit' 
  -> Bool -- ^ 'extendedSubscriptionResponseModelCanExtendVoiceLimit' 
  -> Bool -- ^ 'extendedSubscriptionResponseModelCanUseInstantVoiceCloning' 
  -> Bool -- ^ 'extendedSubscriptionResponseModelCanUseProfessionalVoiceCloning' 
  -> E'Currency -- ^ 'extendedSubscriptionResponseModelCurrency' 
  -> E'Status -- ^ 'extendedSubscriptionResponseModelStatus' 
  -> InvoiceResponseModel -- ^ 'extendedSubscriptionResponseModelNextInvoice' 
  -> Bool -- ^ 'extendedSubscriptionResponseModelHasOpenInvoices' 
  -> ExtendedSubscriptionResponseModel
mkExtendedSubscriptionResponseModel extendedSubscriptionResponseModelTier extendedSubscriptionResponseModelCharacterCount extendedSubscriptionResponseModelCharacterLimit extendedSubscriptionResponseModelCanExtendCharacterLimit extendedSubscriptionResponseModelAllowedToExtendCharacterLimit extendedSubscriptionResponseModelNextCharacterCountResetUnix extendedSubscriptionResponseModelVoiceLimit extendedSubscriptionResponseModelProfessionalVoiceLimit extendedSubscriptionResponseModelCanExtendVoiceLimit extendedSubscriptionResponseModelCanUseInstantVoiceCloning extendedSubscriptionResponseModelCanUseProfessionalVoiceCloning extendedSubscriptionResponseModelCurrency extendedSubscriptionResponseModelStatus extendedSubscriptionResponseModelNextInvoice extendedSubscriptionResponseModelHasOpenInvoices =
  ExtendedSubscriptionResponseModel
  { extendedSubscriptionResponseModelTier
  , extendedSubscriptionResponseModelCharacterCount
  , extendedSubscriptionResponseModelCharacterLimit
  , extendedSubscriptionResponseModelCanExtendCharacterLimit
  , extendedSubscriptionResponseModelAllowedToExtendCharacterLimit
  , extendedSubscriptionResponseModelNextCharacterCountResetUnix
  , extendedSubscriptionResponseModelVoiceLimit
  , extendedSubscriptionResponseModelProfessionalVoiceLimit
  , extendedSubscriptionResponseModelCanExtendVoiceLimit
  , extendedSubscriptionResponseModelCanUseInstantVoiceCloning
  , extendedSubscriptionResponseModelCanUseProfessionalVoiceCloning
  , extendedSubscriptionResponseModelCurrency
  , extendedSubscriptionResponseModelStatus
  , extendedSubscriptionResponseModelNextInvoice
  , extendedSubscriptionResponseModelHasOpenInvoices
  }

-- ** FeedbackResponseModel
-- | FeedbackResponseModel
-- FeedbackResponseModel
-- 
data FeedbackResponseModel = FeedbackResponseModel
  { feedbackResponseModelThumbsUp :: !(Bool) -- ^ /Required/ "thumbs_up"
  , feedbackResponseModelFeedback :: !(Text) -- ^ /Required/ "feedback"
  , feedbackResponseModelEmotions :: !(Bool) -- ^ /Required/ "emotions"
  , feedbackResponseModelInaccurateClone :: !(Bool) -- ^ /Required/ "inaccurate_clone"
  , feedbackResponseModelGlitches :: !(Bool) -- ^ /Required/ "glitches"
  , feedbackResponseModelAudioQuality :: !(Bool) -- ^ /Required/ "audio_quality"
  , feedbackResponseModelOther :: !(Bool) -- ^ /Required/ "other"
  , feedbackResponseModelReviewStatus :: !(Maybe Text) -- ^ "review_status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeedbackResponseModel
instance A.FromJSON FeedbackResponseModel where
  parseJSON = A.withObject "FeedbackResponseModel" $ \o ->
    FeedbackResponseModel
      <$> (o .:  "thumbs_up")
      <*> (o .:  "feedback")
      <*> (o .:  "emotions")
      <*> (o .:  "inaccurate_clone")
      <*> (o .:  "glitches")
      <*> (o .:  "audio_quality")
      <*> (o .:  "other")
      <*> (o .:? "review_status")

-- | ToJSON FeedbackResponseModel
instance A.ToJSON FeedbackResponseModel where
  toJSON FeedbackResponseModel {..} =
   _omitNulls
      [ "thumbs_up" .= feedbackResponseModelThumbsUp
      , "feedback" .= feedbackResponseModelFeedback
      , "emotions" .= feedbackResponseModelEmotions
      , "inaccurate_clone" .= feedbackResponseModelInaccurateClone
      , "glitches" .= feedbackResponseModelGlitches
      , "audio_quality" .= feedbackResponseModelAudioQuality
      , "other" .= feedbackResponseModelOther
      , "review_status" .= feedbackResponseModelReviewStatus
      ]


-- | Construct a value of type 'FeedbackResponseModel' (by applying it's required fields, if any)
mkFeedbackResponseModel
  :: Bool -- ^ 'feedbackResponseModelThumbsUp' 
  -> Text -- ^ 'feedbackResponseModelFeedback' 
  -> Bool -- ^ 'feedbackResponseModelEmotions' 
  -> Bool -- ^ 'feedbackResponseModelInaccurateClone' 
  -> Bool -- ^ 'feedbackResponseModelGlitches' 
  -> Bool -- ^ 'feedbackResponseModelAudioQuality' 
  -> Bool -- ^ 'feedbackResponseModelOther' 
  -> FeedbackResponseModel
mkFeedbackResponseModel feedbackResponseModelThumbsUp feedbackResponseModelFeedback feedbackResponseModelEmotions feedbackResponseModelInaccurateClone feedbackResponseModelGlitches feedbackResponseModelAudioQuality feedbackResponseModelOther =
  FeedbackResponseModel
  { feedbackResponseModelThumbsUp
  , feedbackResponseModelFeedback
  , feedbackResponseModelEmotions
  , feedbackResponseModelInaccurateClone
  , feedbackResponseModelGlitches
  , feedbackResponseModelAudioQuality
  , feedbackResponseModelOther
  , feedbackResponseModelReviewStatus = Nothing
  }

-- ** FineTuningResponseModel
-- | FineTuningResponseModel
-- FineTuningResponseModel
-- 
data FineTuningResponseModel = FineTuningResponseModel
  { fineTuningResponseModelModelId :: !(Text) -- ^ /Required/ "model_id"
  , fineTuningResponseModelLanguage :: !(Text) -- ^ /Required/ "language"
  , fineTuningResponseModelIsAllowedToFineTune :: !(Bool) -- ^ /Required/ "is_allowed_to_fine_tune"
  , fineTuningResponseModelFineTuningRequested :: !(Bool) -- ^ /Required/ "fine_tuning_requested"
  , fineTuningResponseModelFinetuningState :: !(E'FinetuningState) -- ^ /Required/ "finetuning_state"
  , fineTuningResponseModelVerificationAttempts :: !([VerificationAttemptResponseModel]) -- ^ /Required/ "verification_attempts"
  , fineTuningResponseModelVerificationFailures :: !([Text]) -- ^ /Required/ "verification_failures"
  , fineTuningResponseModelVerificationAttemptsCount :: !(Int) -- ^ /Required/ "verification_attempts_count"
  , fineTuningResponseModelSliceIds :: !([Text]) -- ^ /Required/ "slice_ids"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FineTuningResponseModel
instance A.FromJSON FineTuningResponseModel where
  parseJSON = A.withObject "FineTuningResponseModel" $ \o ->
    FineTuningResponseModel
      <$> (o .:  "model_id")
      <*> (o .:  "language")
      <*> (o .:  "is_allowed_to_fine_tune")
      <*> (o .:  "fine_tuning_requested")
      <*> (o .:  "finetuning_state")
      <*> (o .:  "verification_attempts")
      <*> (o .:  "verification_failures")
      <*> (o .:  "verification_attempts_count")
      <*> (o .:  "slice_ids")

-- | ToJSON FineTuningResponseModel
instance A.ToJSON FineTuningResponseModel where
  toJSON FineTuningResponseModel {..} =
   _omitNulls
      [ "model_id" .= fineTuningResponseModelModelId
      , "language" .= fineTuningResponseModelLanguage
      , "is_allowed_to_fine_tune" .= fineTuningResponseModelIsAllowedToFineTune
      , "fine_tuning_requested" .= fineTuningResponseModelFineTuningRequested
      , "finetuning_state" .= fineTuningResponseModelFinetuningState
      , "verification_attempts" .= fineTuningResponseModelVerificationAttempts
      , "verification_failures" .= fineTuningResponseModelVerificationFailures
      , "verification_attempts_count" .= fineTuningResponseModelVerificationAttemptsCount
      , "slice_ids" .= fineTuningResponseModelSliceIds
      ]


-- | Construct a value of type 'FineTuningResponseModel' (by applying it's required fields, if any)
mkFineTuningResponseModel
  :: Text -- ^ 'fineTuningResponseModelModelId' 
  -> Text -- ^ 'fineTuningResponseModelLanguage' 
  -> Bool -- ^ 'fineTuningResponseModelIsAllowedToFineTune' 
  -> Bool -- ^ 'fineTuningResponseModelFineTuningRequested' 
  -> E'FinetuningState -- ^ 'fineTuningResponseModelFinetuningState' 
  -> [VerificationAttemptResponseModel] -- ^ 'fineTuningResponseModelVerificationAttempts' 
  -> [Text] -- ^ 'fineTuningResponseModelVerificationFailures' 
  -> Int -- ^ 'fineTuningResponseModelVerificationAttemptsCount' 
  -> [Text] -- ^ 'fineTuningResponseModelSliceIds' 
  -> FineTuningResponseModel
mkFineTuningResponseModel fineTuningResponseModelModelId fineTuningResponseModelLanguage fineTuningResponseModelIsAllowedToFineTune fineTuningResponseModelFineTuningRequested fineTuningResponseModelFinetuningState fineTuningResponseModelVerificationAttempts fineTuningResponseModelVerificationFailures fineTuningResponseModelVerificationAttemptsCount fineTuningResponseModelSliceIds =
  FineTuningResponseModel
  { fineTuningResponseModelModelId
  , fineTuningResponseModelLanguage
  , fineTuningResponseModelIsAllowedToFineTune
  , fineTuningResponseModelFineTuningRequested
  , fineTuningResponseModelFinetuningState
  , fineTuningResponseModelVerificationAttempts
  , fineTuningResponseModelVerificationFailures
  , fineTuningResponseModelVerificationAttemptsCount
  , fineTuningResponseModelSliceIds
  }

-- ** GetHistoryResponseModel
-- | GetHistoryResponseModel
-- GetHistoryResponseModel
-- 
data GetHistoryResponseModel = GetHistoryResponseModel
  { getHistoryResponseModelHistory :: !([HistoryItemResponseModel]) -- ^ /Required/ "history"
  , getHistoryResponseModelLastHistoryItemId :: !(Text) -- ^ /Required/ "last_history_item_id"
  , getHistoryResponseModelHasMore :: !(Bool) -- ^ /Required/ "has_more"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetHistoryResponseModel
instance A.FromJSON GetHistoryResponseModel where
  parseJSON = A.withObject "GetHistoryResponseModel" $ \o ->
    GetHistoryResponseModel
      <$> (o .:  "history")
      <*> (o .:  "last_history_item_id")
      <*> (o .:  "has_more")

-- | ToJSON GetHistoryResponseModel
instance A.ToJSON GetHistoryResponseModel where
  toJSON GetHistoryResponseModel {..} =
   _omitNulls
      [ "history" .= getHistoryResponseModelHistory
      , "last_history_item_id" .= getHistoryResponseModelLastHistoryItemId
      , "has_more" .= getHistoryResponseModelHasMore
      ]


-- | Construct a value of type 'GetHistoryResponseModel' (by applying it's required fields, if any)
mkGetHistoryResponseModel
  :: [HistoryItemResponseModel] -- ^ 'getHistoryResponseModelHistory' 
  -> Text -- ^ 'getHistoryResponseModelLastHistoryItemId' 
  -> Bool -- ^ 'getHistoryResponseModelHasMore' 
  -> GetHistoryResponseModel
mkGetHistoryResponseModel getHistoryResponseModelHistory getHistoryResponseModelLastHistoryItemId getHistoryResponseModelHasMore =
  GetHistoryResponseModel
  { getHistoryResponseModelHistory
  , getHistoryResponseModelLastHistoryItemId
  , getHistoryResponseModelHasMore
  }

-- ** GetVoicesResponseModel
-- | GetVoicesResponseModel
-- GetVoicesResponseModel
-- 
data GetVoicesResponseModel = GetVoicesResponseModel
  { getVoicesResponseModelVoices :: !([VoiceResponseModel]) -- ^ /Required/ "voices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetVoicesResponseModel
instance A.FromJSON GetVoicesResponseModel where
  parseJSON = A.withObject "GetVoicesResponseModel" $ \o ->
    GetVoicesResponseModel
      <$> (o .:  "voices")

-- | ToJSON GetVoicesResponseModel
instance A.ToJSON GetVoicesResponseModel where
  toJSON GetVoicesResponseModel {..} =
   _omitNulls
      [ "voices" .= getVoicesResponseModelVoices
      ]


-- | Construct a value of type 'GetVoicesResponseModel' (by applying it's required fields, if any)
mkGetVoicesResponseModel
  :: [VoiceResponseModel] -- ^ 'getVoicesResponseModelVoices' 
  -> GetVoicesResponseModel
mkGetVoicesResponseModel getVoicesResponseModelVoices =
  GetVoicesResponseModel
  { getVoicesResponseModelVoices
  }

-- ** HTTPValidationError
-- | HTTPValidationError
-- HTTPValidationError
-- 
data HTTPValidationError = HTTPValidationError
  { hTTPValidationErrorDetail :: !(Maybe [ValidationError]) -- ^ "detail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HTTPValidationError
instance A.FromJSON HTTPValidationError where
  parseJSON = A.withObject "HTTPValidationError" $ \o ->
    HTTPValidationError
      <$> (o .:? "detail")

-- | ToJSON HTTPValidationError
instance A.ToJSON HTTPValidationError where
  toJSON HTTPValidationError {..} =
   _omitNulls
      [ "detail" .= hTTPValidationErrorDetail
      ]


-- | Construct a value of type 'HTTPValidationError' (by applying it's required fields, if any)
mkHTTPValidationError
  :: HTTPValidationError
mkHTTPValidationError =
  HTTPValidationError
  { hTTPValidationErrorDetail = Nothing
  }

-- ** HistoryItemResponseModel
-- | HistoryItemResponseModel
-- HistoryItemResponseModel
-- 
data HistoryItemResponseModel = HistoryItemResponseModel
  { historyItemResponseModelHistoryItemId :: !(Text) -- ^ /Required/ "history_item_id"
  , historyItemResponseModelRequestId :: !(Text) -- ^ /Required/ "request_id"
  , historyItemResponseModelVoiceId :: !(Text) -- ^ /Required/ "voice_id"
  , historyItemResponseModelVoiceName :: !(Text) -- ^ /Required/ "voice_name"
  , historyItemResponseModelText :: !(Text) -- ^ /Required/ "text"
  , historyItemResponseModelDateUnix :: !(Int) -- ^ /Required/ "date_unix"
  , historyItemResponseModelCharacterCountChangeFrom :: !(Int) -- ^ /Required/ "character_count_change_from"
  , historyItemResponseModelCharacterCountChangeTo :: !(Int) -- ^ /Required/ "character_count_change_to"
  , historyItemResponseModelContentType :: !(Text) -- ^ /Required/ "content_type"
  , historyItemResponseModelState :: !(E'State) -- ^ /Required/ "state"
  , historyItemResponseModelSettings :: !(A.Value) -- ^ /Required/ "settings"
  , historyItemResponseModelFeedback :: !(FeedbackResponseModel) -- ^ /Required/ "feedback"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HistoryItemResponseModel
instance A.FromJSON HistoryItemResponseModel where
  parseJSON = A.withObject "HistoryItemResponseModel" $ \o ->
    HistoryItemResponseModel
      <$> (o .:  "history_item_id")
      <*> (o .:  "request_id")
      <*> (o .:  "voice_id")
      <*> (o .:  "voice_name")
      <*> (o .:  "text")
      <*> (o .:  "date_unix")
      <*> (o .:  "character_count_change_from")
      <*> (o .:  "character_count_change_to")
      <*> (o .:  "content_type")
      <*> (o .:  "state")
      <*> (o .:  "settings")
      <*> (o .:  "feedback")

-- | ToJSON HistoryItemResponseModel
instance A.ToJSON HistoryItemResponseModel where
  toJSON HistoryItemResponseModel {..} =
   _omitNulls
      [ "history_item_id" .= historyItemResponseModelHistoryItemId
      , "request_id" .= historyItemResponseModelRequestId
      , "voice_id" .= historyItemResponseModelVoiceId
      , "voice_name" .= historyItemResponseModelVoiceName
      , "text" .= historyItemResponseModelText
      , "date_unix" .= historyItemResponseModelDateUnix
      , "character_count_change_from" .= historyItemResponseModelCharacterCountChangeFrom
      , "character_count_change_to" .= historyItemResponseModelCharacterCountChangeTo
      , "content_type" .= historyItemResponseModelContentType
      , "state" .= historyItemResponseModelState
      , "settings" .= historyItemResponseModelSettings
      , "feedback" .= historyItemResponseModelFeedback
      ]


-- | Construct a value of type 'HistoryItemResponseModel' (by applying it's required fields, if any)
mkHistoryItemResponseModel
  :: Text -- ^ 'historyItemResponseModelHistoryItemId' 
  -> Text -- ^ 'historyItemResponseModelRequestId' 
  -> Text -- ^ 'historyItemResponseModelVoiceId' 
  -> Text -- ^ 'historyItemResponseModelVoiceName' 
  -> Text -- ^ 'historyItemResponseModelText' 
  -> Int -- ^ 'historyItemResponseModelDateUnix' 
  -> Int -- ^ 'historyItemResponseModelCharacterCountChangeFrom' 
  -> Int -- ^ 'historyItemResponseModelCharacterCountChangeTo' 
  -> Text -- ^ 'historyItemResponseModelContentType' 
  -> E'State -- ^ 'historyItemResponseModelState' 
  -> A.Value -- ^ 'historyItemResponseModelSettings' 
  -> FeedbackResponseModel -- ^ 'historyItemResponseModelFeedback' 
  -> HistoryItemResponseModel
mkHistoryItemResponseModel historyItemResponseModelHistoryItemId historyItemResponseModelRequestId historyItemResponseModelVoiceId historyItemResponseModelVoiceName historyItemResponseModelText historyItemResponseModelDateUnix historyItemResponseModelCharacterCountChangeFrom historyItemResponseModelCharacterCountChangeTo historyItemResponseModelContentType historyItemResponseModelState historyItemResponseModelSettings historyItemResponseModelFeedback =
  HistoryItemResponseModel
  { historyItemResponseModelHistoryItemId
  , historyItemResponseModelRequestId
  , historyItemResponseModelVoiceId
  , historyItemResponseModelVoiceName
  , historyItemResponseModelText
  , historyItemResponseModelDateUnix
  , historyItemResponseModelCharacterCountChangeFrom
  , historyItemResponseModelCharacterCountChangeTo
  , historyItemResponseModelContentType
  , historyItemResponseModelState
  , historyItemResponseModelSettings
  , historyItemResponseModelFeedback
  }

-- ** InvoiceResponseModel
-- | InvoiceResponseModel
-- InvoiceResponseModel
-- 
data InvoiceResponseModel = InvoiceResponseModel
  { invoiceResponseModelAmountDueCents :: !(Int) -- ^ /Required/ "amount_due_cents"
  , invoiceResponseModelNextPaymentAttemptUnix :: !(Int) -- ^ /Required/ "next_payment_attempt_unix"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvoiceResponseModel
instance A.FromJSON InvoiceResponseModel where
  parseJSON = A.withObject "InvoiceResponseModel" $ \o ->
    InvoiceResponseModel
      <$> (o .:  "amount_due_cents")
      <*> (o .:  "next_payment_attempt_unix")

-- | ToJSON InvoiceResponseModel
instance A.ToJSON InvoiceResponseModel where
  toJSON InvoiceResponseModel {..} =
   _omitNulls
      [ "amount_due_cents" .= invoiceResponseModelAmountDueCents
      , "next_payment_attempt_unix" .= invoiceResponseModelNextPaymentAttemptUnix
      ]


-- | Construct a value of type 'InvoiceResponseModel' (by applying it's required fields, if any)
mkInvoiceResponseModel
  :: Int -- ^ 'invoiceResponseModelAmountDueCents' 
  -> Int -- ^ 'invoiceResponseModelNextPaymentAttemptUnix' 
  -> InvoiceResponseModel
mkInvoiceResponseModel invoiceResponseModelAmountDueCents invoiceResponseModelNextPaymentAttemptUnix =
  InvoiceResponseModel
  { invoiceResponseModelAmountDueCents
  , invoiceResponseModelNextPaymentAttemptUnix
  }

-- ** LanguageResponseModel
-- | LanguageResponseModel
-- LanguageResponseModel
-- 
data LanguageResponseModel = LanguageResponseModel
  { languageResponseModelLanguageId :: !(Text) -- ^ /Required/ "language_id"
  , languageResponseModelName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LanguageResponseModel
instance A.FromJSON LanguageResponseModel where
  parseJSON = A.withObject "LanguageResponseModel" $ \o ->
    LanguageResponseModel
      <$> (o .:  "language_id")
      <*> (o .:  "name")

-- | ToJSON LanguageResponseModel
instance A.ToJSON LanguageResponseModel where
  toJSON LanguageResponseModel {..} =
   _omitNulls
      [ "language_id" .= languageResponseModelLanguageId
      , "name" .= languageResponseModelName
      ]


-- | Construct a value of type 'LanguageResponseModel' (by applying it's required fields, if any)
mkLanguageResponseModel
  :: Text -- ^ 'languageResponseModelLanguageId' 
  -> Text -- ^ 'languageResponseModelName' 
  -> LanguageResponseModel
mkLanguageResponseModel languageResponseModelLanguageId languageResponseModelName =
  LanguageResponseModel
  { languageResponseModelLanguageId
  , languageResponseModelName
  }

-- ** LocationInner
-- | LocationInner
data LocationInner = LocationInner
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LocationInner
instance A.FromJSON LocationInner where
  parseJSON = A.withObject "LocationInner" $ \o ->
    pure LocationInner
      

-- | ToJSON LocationInner
instance A.ToJSON LocationInner where
  toJSON LocationInner  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'LocationInner' (by applying it's required fields, if any)
mkLocationInner
  :: LocationInner
mkLocationInner =
  LocationInner
  { 
  }

-- ** ModelResponseModel
-- | ModelResponseModel
-- ModelResponseModel
-- 
data ModelResponseModel = ModelResponseModel
  { modelResponseModelModelId :: !(Text) -- ^ /Required/ "model_id"
  , modelResponseModelName :: !(Text) -- ^ /Required/ "name"
  , modelResponseModelCanBeFinetuned :: !(Bool) -- ^ /Required/ "can_be_finetuned"
  , modelResponseModelCanDoTextToSpeech :: !(Bool) -- ^ /Required/ "can_do_text_to_speech"
  , modelResponseModelCanDoVoiceConversion :: !(Bool) -- ^ /Required/ "can_do_voice_conversion"
  , modelResponseModelTokenCostFactor :: !(Double) -- ^ /Required/ "token_cost_factor"
  , modelResponseModelDescription :: !(Text) -- ^ /Required/ "description"
  , modelResponseModelLanguages :: !([LanguageResponseModel]) -- ^ /Required/ "languages"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelResponseModel
instance A.FromJSON ModelResponseModel where
  parseJSON = A.withObject "ModelResponseModel" $ \o ->
    ModelResponseModel
      <$> (o .:  "model_id")
      <*> (o .:  "name")
      <*> (o .:  "can_be_finetuned")
      <*> (o .:  "can_do_text_to_speech")
      <*> (o .:  "can_do_voice_conversion")
      <*> (o .:  "token_cost_factor")
      <*> (o .:  "description")
      <*> (o .:  "languages")

-- | ToJSON ModelResponseModel
instance A.ToJSON ModelResponseModel where
  toJSON ModelResponseModel {..} =
   _omitNulls
      [ "model_id" .= modelResponseModelModelId
      , "name" .= modelResponseModelName
      , "can_be_finetuned" .= modelResponseModelCanBeFinetuned
      , "can_do_text_to_speech" .= modelResponseModelCanDoTextToSpeech
      , "can_do_voice_conversion" .= modelResponseModelCanDoVoiceConversion
      , "token_cost_factor" .= modelResponseModelTokenCostFactor
      , "description" .= modelResponseModelDescription
      , "languages" .= modelResponseModelLanguages
      ]


-- | Construct a value of type 'ModelResponseModel' (by applying it's required fields, if any)
mkModelResponseModel
  :: Text -- ^ 'modelResponseModelModelId' 
  -> Text -- ^ 'modelResponseModelName' 
  -> Bool -- ^ 'modelResponseModelCanBeFinetuned' 
  -> Bool -- ^ 'modelResponseModelCanDoTextToSpeech' 
  -> Bool -- ^ 'modelResponseModelCanDoVoiceConversion' 
  -> Double -- ^ 'modelResponseModelTokenCostFactor' 
  -> Text -- ^ 'modelResponseModelDescription' 
  -> [LanguageResponseModel] -- ^ 'modelResponseModelLanguages' 
  -> ModelResponseModel
mkModelResponseModel modelResponseModelModelId modelResponseModelName modelResponseModelCanBeFinetuned modelResponseModelCanDoTextToSpeech modelResponseModelCanDoVoiceConversion modelResponseModelTokenCostFactor modelResponseModelDescription modelResponseModelLanguages =
  ModelResponseModel
  { modelResponseModelModelId
  , modelResponseModelName
  , modelResponseModelCanBeFinetuned
  , modelResponseModelCanDoTextToSpeech
  , modelResponseModelCanDoVoiceConversion
  , modelResponseModelTokenCostFactor
  , modelResponseModelDescription
  , modelResponseModelLanguages
  }

-- ** RecordingResponseModel
-- | RecordingResponseModel
-- RecordingResponseModel
-- 
data RecordingResponseModel = RecordingResponseModel
  { recordingResponseModelRecordingId :: !(Text) -- ^ /Required/ "recording_id"
  , recordingResponseModelMimeType :: !(Text) -- ^ /Required/ "mime_type"
  , recordingResponseModelSizeBytes :: !(Int) -- ^ /Required/ "size_bytes"
  , recordingResponseModelUploadDateUnix :: !(Int) -- ^ /Required/ "upload_date_unix"
  , recordingResponseModelTranscription :: !(Text) -- ^ /Required/ "transcription"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecordingResponseModel
instance A.FromJSON RecordingResponseModel where
  parseJSON = A.withObject "RecordingResponseModel" $ \o ->
    RecordingResponseModel
      <$> (o .:  "recording_id")
      <*> (o .:  "mime_type")
      <*> (o .:  "size_bytes")
      <*> (o .:  "upload_date_unix")
      <*> (o .:  "transcription")

-- | ToJSON RecordingResponseModel
instance A.ToJSON RecordingResponseModel where
  toJSON RecordingResponseModel {..} =
   _omitNulls
      [ "recording_id" .= recordingResponseModelRecordingId
      , "mime_type" .= recordingResponseModelMimeType
      , "size_bytes" .= recordingResponseModelSizeBytes
      , "upload_date_unix" .= recordingResponseModelUploadDateUnix
      , "transcription" .= recordingResponseModelTranscription
      ]


-- | Construct a value of type 'RecordingResponseModel' (by applying it's required fields, if any)
mkRecordingResponseModel
  :: Text -- ^ 'recordingResponseModelRecordingId' 
  -> Text -- ^ 'recordingResponseModelMimeType' 
  -> Int -- ^ 'recordingResponseModelSizeBytes' 
  -> Int -- ^ 'recordingResponseModelUploadDateUnix' 
  -> Text -- ^ 'recordingResponseModelTranscription' 
  -> RecordingResponseModel
mkRecordingResponseModel recordingResponseModelRecordingId recordingResponseModelMimeType recordingResponseModelSizeBytes recordingResponseModelUploadDateUnix recordingResponseModelTranscription =
  RecordingResponseModel
  { recordingResponseModelRecordingId
  , recordingResponseModelMimeType
  , recordingResponseModelSizeBytes
  , recordingResponseModelUploadDateUnix
  , recordingResponseModelTranscription
  }

-- ** SampleResponseModel
-- | SampleResponseModel
-- SampleResponseModel
-- 
data SampleResponseModel = SampleResponseModel
  { sampleResponseModelSampleId :: !(Text) -- ^ /Required/ "sample_id"
  , sampleResponseModelFileName :: !(Text) -- ^ /Required/ "file_name"
  , sampleResponseModelMimeType :: !(Text) -- ^ /Required/ "mime_type"
  , sampleResponseModelSizeBytes :: !(Int) -- ^ /Required/ "size_bytes"
  , sampleResponseModelHash :: !(Text) -- ^ /Required/ "hash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SampleResponseModel
instance A.FromJSON SampleResponseModel where
  parseJSON = A.withObject "SampleResponseModel" $ \o ->
    SampleResponseModel
      <$> (o .:  "sample_id")
      <*> (o .:  "file_name")
      <*> (o .:  "mime_type")
      <*> (o .:  "size_bytes")
      <*> (o .:  "hash")

-- | ToJSON SampleResponseModel
instance A.ToJSON SampleResponseModel where
  toJSON SampleResponseModel {..} =
   _omitNulls
      [ "sample_id" .= sampleResponseModelSampleId
      , "file_name" .= sampleResponseModelFileName
      , "mime_type" .= sampleResponseModelMimeType
      , "size_bytes" .= sampleResponseModelSizeBytes
      , "hash" .= sampleResponseModelHash
      ]


-- | Construct a value of type 'SampleResponseModel' (by applying it's required fields, if any)
mkSampleResponseModel
  :: Text -- ^ 'sampleResponseModelSampleId' 
  -> Text -- ^ 'sampleResponseModelFileName' 
  -> Text -- ^ 'sampleResponseModelMimeType' 
  -> Int -- ^ 'sampleResponseModelSizeBytes' 
  -> Text -- ^ 'sampleResponseModelHash' 
  -> SampleResponseModel
mkSampleResponseModel sampleResponseModelSampleId sampleResponseModelFileName sampleResponseModelMimeType sampleResponseModelSizeBytes sampleResponseModelHash =
  SampleResponseModel
  { sampleResponseModelSampleId
  , sampleResponseModelFileName
  , sampleResponseModelMimeType
  , sampleResponseModelSizeBytes
  , sampleResponseModelHash
  }

-- ** Settings
-- | Settings
-- Settings
-- 
-- The settings for a specific voice.
data Settings = Settings
  { settingsStability :: !(Double) -- ^ /Required/ "stability"
  , settingsSimilarityBoost :: !(Double) -- ^ /Required/ "similarity_boost"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Settings
instance A.FromJSON Settings where
  parseJSON = A.withObject "Settings" $ \o ->
    Settings
      <$> (o .:  "stability")
      <*> (o .:  "similarity_boost")

-- | ToJSON Settings
instance A.ToJSON Settings where
  toJSON Settings {..} =
   _omitNulls
      [ "stability" .= settingsStability
      , "similarity_boost" .= settingsSimilarityBoost
      ]


-- | Construct a value of type 'Settings' (by applying it's required fields, if any)
mkSettings
  :: Double -- ^ 'settingsStability' 
  -> Double -- ^ 'settingsSimilarityBoost' 
  -> Settings
mkSettings settingsStability settingsSimilarityBoost =
  Settings
  { settingsStability
  , settingsSimilarityBoost
  }

-- ** SubscriptionResponseModel
-- | SubscriptionResponseModel
-- SubscriptionResponseModel
-- 
data SubscriptionResponseModel = SubscriptionResponseModel
  { subscriptionResponseModelTier :: !(Text) -- ^ /Required/ "tier"
  , subscriptionResponseModelCharacterCount :: !(Int) -- ^ /Required/ "character_count"
  , subscriptionResponseModelCharacterLimit :: !(Int) -- ^ /Required/ "character_limit"
  , subscriptionResponseModelCanExtendCharacterLimit :: !(Bool) -- ^ /Required/ "can_extend_character_limit"
  , subscriptionResponseModelAllowedToExtendCharacterLimit :: !(Bool) -- ^ /Required/ "allowed_to_extend_character_limit"
  , subscriptionResponseModelNextCharacterCountResetUnix :: !(Int) -- ^ /Required/ "next_character_count_reset_unix"
  , subscriptionResponseModelVoiceLimit :: !(Int) -- ^ /Required/ "voice_limit"
  , subscriptionResponseModelProfessionalVoiceLimit :: !(Int) -- ^ /Required/ "professional_voice_limit"
  , subscriptionResponseModelCanExtendVoiceLimit :: !(Bool) -- ^ /Required/ "can_extend_voice_limit"
  , subscriptionResponseModelCanUseInstantVoiceCloning :: !(Bool) -- ^ /Required/ "can_use_instant_voice_cloning"
  , subscriptionResponseModelCanUseProfessionalVoiceCloning :: !(Bool) -- ^ /Required/ "can_use_professional_voice_cloning"
  , subscriptionResponseModelCurrency :: !(E'Currency) -- ^ /Required/ "currency"
  , subscriptionResponseModelStatus :: !(E'Status) -- ^ /Required/ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SubscriptionResponseModel
instance A.FromJSON SubscriptionResponseModel where
  parseJSON = A.withObject "SubscriptionResponseModel" $ \o ->
    SubscriptionResponseModel
      <$> (o .:  "tier")
      <*> (o .:  "character_count")
      <*> (o .:  "character_limit")
      <*> (o .:  "can_extend_character_limit")
      <*> (o .:  "allowed_to_extend_character_limit")
      <*> (o .:  "next_character_count_reset_unix")
      <*> (o .:  "voice_limit")
      <*> (o .:  "professional_voice_limit")
      <*> (o .:  "can_extend_voice_limit")
      <*> (o .:  "can_use_instant_voice_cloning")
      <*> (o .:  "can_use_professional_voice_cloning")
      <*> (o .:  "currency")
      <*> (o .:  "status")

-- | ToJSON SubscriptionResponseModel
instance A.ToJSON SubscriptionResponseModel where
  toJSON SubscriptionResponseModel {..} =
   _omitNulls
      [ "tier" .= subscriptionResponseModelTier
      , "character_count" .= subscriptionResponseModelCharacterCount
      , "character_limit" .= subscriptionResponseModelCharacterLimit
      , "can_extend_character_limit" .= subscriptionResponseModelCanExtendCharacterLimit
      , "allowed_to_extend_character_limit" .= subscriptionResponseModelAllowedToExtendCharacterLimit
      , "next_character_count_reset_unix" .= subscriptionResponseModelNextCharacterCountResetUnix
      , "voice_limit" .= subscriptionResponseModelVoiceLimit
      , "professional_voice_limit" .= subscriptionResponseModelProfessionalVoiceLimit
      , "can_extend_voice_limit" .= subscriptionResponseModelCanExtendVoiceLimit
      , "can_use_instant_voice_cloning" .= subscriptionResponseModelCanUseInstantVoiceCloning
      , "can_use_professional_voice_cloning" .= subscriptionResponseModelCanUseProfessionalVoiceCloning
      , "currency" .= subscriptionResponseModelCurrency
      , "status" .= subscriptionResponseModelStatus
      ]


-- | Construct a value of type 'SubscriptionResponseModel' (by applying it's required fields, if any)
mkSubscriptionResponseModel
  :: Text -- ^ 'subscriptionResponseModelTier' 
  -> Int -- ^ 'subscriptionResponseModelCharacterCount' 
  -> Int -- ^ 'subscriptionResponseModelCharacterLimit' 
  -> Bool -- ^ 'subscriptionResponseModelCanExtendCharacterLimit' 
  -> Bool -- ^ 'subscriptionResponseModelAllowedToExtendCharacterLimit' 
  -> Int -- ^ 'subscriptionResponseModelNextCharacterCountResetUnix' 
  -> Int -- ^ 'subscriptionResponseModelVoiceLimit' 
  -> Int -- ^ 'subscriptionResponseModelProfessionalVoiceLimit' 
  -> Bool -- ^ 'subscriptionResponseModelCanExtendVoiceLimit' 
  -> Bool -- ^ 'subscriptionResponseModelCanUseInstantVoiceCloning' 
  -> Bool -- ^ 'subscriptionResponseModelCanUseProfessionalVoiceCloning' 
  -> E'Currency -- ^ 'subscriptionResponseModelCurrency' 
  -> E'Status -- ^ 'subscriptionResponseModelStatus' 
  -> SubscriptionResponseModel
mkSubscriptionResponseModel subscriptionResponseModelTier subscriptionResponseModelCharacterCount subscriptionResponseModelCharacterLimit subscriptionResponseModelCanExtendCharacterLimit subscriptionResponseModelAllowedToExtendCharacterLimit subscriptionResponseModelNextCharacterCountResetUnix subscriptionResponseModelVoiceLimit subscriptionResponseModelProfessionalVoiceLimit subscriptionResponseModelCanExtendVoiceLimit subscriptionResponseModelCanUseInstantVoiceCloning subscriptionResponseModelCanUseProfessionalVoiceCloning subscriptionResponseModelCurrency subscriptionResponseModelStatus =
  SubscriptionResponseModel
  { subscriptionResponseModelTier
  , subscriptionResponseModelCharacterCount
  , subscriptionResponseModelCharacterLimit
  , subscriptionResponseModelCanExtendCharacterLimit
  , subscriptionResponseModelAllowedToExtendCharacterLimit
  , subscriptionResponseModelNextCharacterCountResetUnix
  , subscriptionResponseModelVoiceLimit
  , subscriptionResponseModelProfessionalVoiceLimit
  , subscriptionResponseModelCanExtendVoiceLimit
  , subscriptionResponseModelCanUseInstantVoiceCloning
  , subscriptionResponseModelCanUseProfessionalVoiceCloning
  , subscriptionResponseModelCurrency
  , subscriptionResponseModelStatus
  }

-- ** UserResponseModel
-- | UserResponseModel
-- UserResponseModel
-- 
data UserResponseModel = UserResponseModel
  { userResponseModelSubscription :: !(SubscriptionResponseModel) -- ^ /Required/ "subscription"
  , userResponseModelIsNewUser :: !(Bool) -- ^ /Required/ "is_new_user"
  , userResponseModelXiApiKey :: !(Text) -- ^ /Required/ "xi_api_key"
  , userResponseModelCanUseDelayedPaymentMethods :: !(Bool) -- ^ /Required/ "can_use_delayed_payment_methods"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserResponseModel
instance A.FromJSON UserResponseModel where
  parseJSON = A.withObject "UserResponseModel" $ \o ->
    UserResponseModel
      <$> (o .:  "subscription")
      <*> (o .:  "is_new_user")
      <*> (o .:  "xi_api_key")
      <*> (o .:  "can_use_delayed_payment_methods")

-- | ToJSON UserResponseModel
instance A.ToJSON UserResponseModel where
  toJSON UserResponseModel {..} =
   _omitNulls
      [ "subscription" .= userResponseModelSubscription
      , "is_new_user" .= userResponseModelIsNewUser
      , "xi_api_key" .= userResponseModelXiApiKey
      , "can_use_delayed_payment_methods" .= userResponseModelCanUseDelayedPaymentMethods
      ]


-- | Construct a value of type 'UserResponseModel' (by applying it's required fields, if any)
mkUserResponseModel
  :: SubscriptionResponseModel -- ^ 'userResponseModelSubscription' 
  -> Bool -- ^ 'userResponseModelIsNewUser' 
  -> Text -- ^ 'userResponseModelXiApiKey' 
  -> Bool -- ^ 'userResponseModelCanUseDelayedPaymentMethods' 
  -> UserResponseModel
mkUserResponseModel userResponseModelSubscription userResponseModelIsNewUser userResponseModelXiApiKey userResponseModelCanUseDelayedPaymentMethods =
  UserResponseModel
  { userResponseModelSubscription
  , userResponseModelIsNewUser
  , userResponseModelXiApiKey
  , userResponseModelCanUseDelayedPaymentMethods
  }

-- ** ValidationError
-- | ValidationError
-- ValidationError
-- 
data ValidationError = ValidationError
  { validationErrorLoc :: !([LocationInner]) -- ^ /Required/ "loc"
  , validationErrorMsg :: !(Text) -- ^ /Required/ "msg"
  , validationErrorType :: !(Text) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ValidationError
instance A.FromJSON ValidationError where
  parseJSON = A.withObject "ValidationError" $ \o ->
    ValidationError
      <$> (o .:  "loc")
      <*> (o .:  "msg")
      <*> (o .:  "type")

-- | ToJSON ValidationError
instance A.ToJSON ValidationError where
  toJSON ValidationError {..} =
   _omitNulls
      [ "loc" .= validationErrorLoc
      , "msg" .= validationErrorMsg
      , "type" .= validationErrorType
      ]


-- | Construct a value of type 'ValidationError' (by applying it's required fields, if any)
mkValidationError
  :: [LocationInner] -- ^ 'validationErrorLoc' 
  -> Text -- ^ 'validationErrorMsg' 
  -> Text -- ^ 'validationErrorType' 
  -> ValidationError
mkValidationError validationErrorLoc validationErrorMsg validationErrorType =
  ValidationError
  { validationErrorLoc
  , validationErrorMsg
  , validationErrorType
  }

-- ** VerificationAttemptResponseModel
-- | VerificationAttemptResponseModel
-- VerificationAttemptResponseModel
-- 
data VerificationAttemptResponseModel = VerificationAttemptResponseModel
  { verificationAttemptResponseModelText :: !(Text) -- ^ /Required/ "text"
  , verificationAttemptResponseModelDateUnix :: !(Int) -- ^ /Required/ "date_unix"
  , verificationAttemptResponseModelAccepted :: !(Bool) -- ^ /Required/ "accepted"
  , verificationAttemptResponseModelSimilarity :: !(Double) -- ^ /Required/ "similarity"
  , verificationAttemptResponseModelLevenshteinDistance :: !(Double) -- ^ /Required/ "levenshtein_distance"
  , verificationAttemptResponseModelRecording :: !(RecordingResponseModel) -- ^ /Required/ "recording"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VerificationAttemptResponseModel
instance A.FromJSON VerificationAttemptResponseModel where
  parseJSON = A.withObject "VerificationAttemptResponseModel" $ \o ->
    VerificationAttemptResponseModel
      <$> (o .:  "text")
      <*> (o .:  "date_unix")
      <*> (o .:  "accepted")
      <*> (o .:  "similarity")
      <*> (o .:  "levenshtein_distance")
      <*> (o .:  "recording")

-- | ToJSON VerificationAttemptResponseModel
instance A.ToJSON VerificationAttemptResponseModel where
  toJSON VerificationAttemptResponseModel {..} =
   _omitNulls
      [ "text" .= verificationAttemptResponseModelText
      , "date_unix" .= verificationAttemptResponseModelDateUnix
      , "accepted" .= verificationAttemptResponseModelAccepted
      , "similarity" .= verificationAttemptResponseModelSimilarity
      , "levenshtein_distance" .= verificationAttemptResponseModelLevenshteinDistance
      , "recording" .= verificationAttemptResponseModelRecording
      ]


-- | Construct a value of type 'VerificationAttemptResponseModel' (by applying it's required fields, if any)
mkVerificationAttemptResponseModel
  :: Text -- ^ 'verificationAttemptResponseModelText' 
  -> Int -- ^ 'verificationAttemptResponseModelDateUnix' 
  -> Bool -- ^ 'verificationAttemptResponseModelAccepted' 
  -> Double -- ^ 'verificationAttemptResponseModelSimilarity' 
  -> Double -- ^ 'verificationAttemptResponseModelLevenshteinDistance' 
  -> RecordingResponseModel -- ^ 'verificationAttemptResponseModelRecording' 
  -> VerificationAttemptResponseModel
mkVerificationAttemptResponseModel verificationAttemptResponseModelText verificationAttemptResponseModelDateUnix verificationAttemptResponseModelAccepted verificationAttemptResponseModelSimilarity verificationAttemptResponseModelLevenshteinDistance verificationAttemptResponseModelRecording =
  VerificationAttemptResponseModel
  { verificationAttemptResponseModelText
  , verificationAttemptResponseModelDateUnix
  , verificationAttemptResponseModelAccepted
  , verificationAttemptResponseModelSimilarity
  , verificationAttemptResponseModelLevenshteinDistance
  , verificationAttemptResponseModelRecording
  }

-- ** VoiceResponseModel
-- | VoiceResponseModel
-- VoiceResponseModel
-- 
data VoiceResponseModel = VoiceResponseModel
  { voiceResponseModelVoiceId :: !(Text) -- ^ /Required/ "voice_id"
  , voiceResponseModelName :: !(Text) -- ^ /Required/ "name"
  , voiceResponseModelSamples :: !([SampleResponseModel]) -- ^ /Required/ "samples"
  , voiceResponseModelCategory :: !(Text) -- ^ /Required/ "category"
  , voiceResponseModelFineTuning :: !(FineTuningResponseModel) -- ^ /Required/ "fine_tuning"
  , voiceResponseModelLabels :: !((Map.Map String Text)) -- ^ /Required/ "labels"
  , voiceResponseModelDescription :: !(Text) -- ^ /Required/ "description"
  , voiceResponseModelPreviewUrl :: !(Text) -- ^ /Required/ "preview_url"
  , voiceResponseModelAvailableForTiers :: !([Text]) -- ^ /Required/ "available_for_tiers"
  , voiceResponseModelSettings :: !(VoiceSettingsResponseModel) -- ^ /Required/ "settings"
  , voiceResponseModelSharing :: !(VoiceSharingResponseModel) -- ^ /Required/ "sharing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VoiceResponseModel
instance A.FromJSON VoiceResponseModel where
  parseJSON = A.withObject "VoiceResponseModel" $ \o ->
    VoiceResponseModel
      <$> (o .:  "voice_id")
      <*> (o .:  "name")
      <*> (o .:  "samples")
      <*> (o .:  "category")
      <*> (o .:  "fine_tuning")
      <*> (o .:  "labels")
      <*> (o .:  "description")
      <*> (o .:  "preview_url")
      <*> (o .:  "available_for_tiers")
      <*> (o .:  "settings")
      <*> (o .:  "sharing")

-- | ToJSON VoiceResponseModel
instance A.ToJSON VoiceResponseModel where
  toJSON VoiceResponseModel {..} =
   _omitNulls
      [ "voice_id" .= voiceResponseModelVoiceId
      , "name" .= voiceResponseModelName
      , "samples" .= voiceResponseModelSamples
      , "category" .= voiceResponseModelCategory
      , "fine_tuning" .= voiceResponseModelFineTuning
      , "labels" .= voiceResponseModelLabels
      , "description" .= voiceResponseModelDescription
      , "preview_url" .= voiceResponseModelPreviewUrl
      , "available_for_tiers" .= voiceResponseModelAvailableForTiers
      , "settings" .= voiceResponseModelSettings
      , "sharing" .= voiceResponseModelSharing
      ]


-- | Construct a value of type 'VoiceResponseModel' (by applying it's required fields, if any)
mkVoiceResponseModel
  :: Text -- ^ 'voiceResponseModelVoiceId' 
  -> Text -- ^ 'voiceResponseModelName' 
  -> [SampleResponseModel] -- ^ 'voiceResponseModelSamples' 
  -> Text -- ^ 'voiceResponseModelCategory' 
  -> FineTuningResponseModel -- ^ 'voiceResponseModelFineTuning' 
  -> (Map.Map String Text) -- ^ 'voiceResponseModelLabels' 
  -> Text -- ^ 'voiceResponseModelDescription' 
  -> Text -- ^ 'voiceResponseModelPreviewUrl' 
  -> [Text] -- ^ 'voiceResponseModelAvailableForTiers' 
  -> VoiceSettingsResponseModel -- ^ 'voiceResponseModelSettings' 
  -> VoiceSharingResponseModel -- ^ 'voiceResponseModelSharing' 
  -> VoiceResponseModel
mkVoiceResponseModel voiceResponseModelVoiceId voiceResponseModelName voiceResponseModelSamples voiceResponseModelCategory voiceResponseModelFineTuning voiceResponseModelLabels voiceResponseModelDescription voiceResponseModelPreviewUrl voiceResponseModelAvailableForTiers voiceResponseModelSettings voiceResponseModelSharing =
  VoiceResponseModel
  { voiceResponseModelVoiceId
  , voiceResponseModelName
  , voiceResponseModelSamples
  , voiceResponseModelCategory
  , voiceResponseModelFineTuning
  , voiceResponseModelLabels
  , voiceResponseModelDescription
  , voiceResponseModelPreviewUrl
  , voiceResponseModelAvailableForTiers
  , voiceResponseModelSettings
  , voiceResponseModelSharing
  }

-- ** VoiceSettings
-- | VoiceSettings
-- Voice Settings
-- 
-- Voice settings overriding stored setttings for the given voice. They are applied only on the given TTS request.
data VoiceSettings = VoiceSettings
  { voiceSettingsStability :: !(Double) -- ^ /Required/ "stability"
  , voiceSettingsSimilarityBoost :: !(Double) -- ^ /Required/ "similarity_boost"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VoiceSettings
instance A.FromJSON VoiceSettings where
  parseJSON = A.withObject "VoiceSettings" $ \o ->
    VoiceSettings
      <$> (o .:  "stability")
      <*> (o .:  "similarity_boost")

-- | ToJSON VoiceSettings
instance A.ToJSON VoiceSettings where
  toJSON VoiceSettings {..} =
   _omitNulls
      [ "stability" .= voiceSettingsStability
      , "similarity_boost" .= voiceSettingsSimilarityBoost
      ]


-- | Construct a value of type 'VoiceSettings' (by applying it's required fields, if any)
mkVoiceSettings
  :: Double -- ^ 'voiceSettingsStability' 
  -> Double -- ^ 'voiceSettingsSimilarityBoost' 
  -> VoiceSettings
mkVoiceSettings voiceSettingsStability voiceSettingsSimilarityBoost =
  VoiceSettings
  { voiceSettingsStability
  , voiceSettingsSimilarityBoost
  }

-- ** VoiceSettingsResponseModel
-- | VoiceSettingsResponseModel
-- VoiceSettingsResponseModel
-- 
data VoiceSettingsResponseModel = VoiceSettingsResponseModel
  { voiceSettingsResponseModelStability :: !(Double) -- ^ /Required/ "stability"
  , voiceSettingsResponseModelSimilarityBoost :: !(Double) -- ^ /Required/ "similarity_boost"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VoiceSettingsResponseModel
instance A.FromJSON VoiceSettingsResponseModel where
  parseJSON = A.withObject "VoiceSettingsResponseModel" $ \o ->
    VoiceSettingsResponseModel
      <$> (o .:  "stability")
      <*> (o .:  "similarity_boost")

-- | ToJSON VoiceSettingsResponseModel
instance A.ToJSON VoiceSettingsResponseModel where
  toJSON VoiceSettingsResponseModel {..} =
   _omitNulls
      [ "stability" .= voiceSettingsResponseModelStability
      , "similarity_boost" .= voiceSettingsResponseModelSimilarityBoost
      ]


-- | Construct a value of type 'VoiceSettingsResponseModel' (by applying it's required fields, if any)
mkVoiceSettingsResponseModel
  :: Double -- ^ 'voiceSettingsResponseModelStability' 
  -> Double -- ^ 'voiceSettingsResponseModelSimilarityBoost' 
  -> VoiceSettingsResponseModel
mkVoiceSettingsResponseModel voiceSettingsResponseModelStability voiceSettingsResponseModelSimilarityBoost =
  VoiceSettingsResponseModel
  { voiceSettingsResponseModelStability
  , voiceSettingsResponseModelSimilarityBoost
  }

-- ** VoiceSharingResponseModel
-- | VoiceSharingResponseModel
-- VoiceSharingResponseModel
-- 
data VoiceSharingResponseModel = VoiceSharingResponseModel
  { voiceSharingResponseModelStatus :: !(Text) -- ^ /Required/ "status"
  , voiceSharingResponseModelHistoryItemSampleId :: !(Text) -- ^ /Required/ "history_item_sample_id"
  , voiceSharingResponseModelOriginalVoiceId :: !(Text) -- ^ /Required/ "original_voice_id"
  , voiceSharingResponseModelPublicOwnerId :: !(Text) -- ^ /Required/ "public_owner_id"
  , voiceSharingResponseModelLikedByCount :: !(Int) -- ^ /Required/ "liked_by_count"
  , voiceSharingResponseModelClonedByCount :: !(Int) -- ^ /Required/ "cloned_by_count"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VoiceSharingResponseModel
instance A.FromJSON VoiceSharingResponseModel where
  parseJSON = A.withObject "VoiceSharingResponseModel" $ \o ->
    VoiceSharingResponseModel
      <$> (o .:  "status")
      <*> (o .:  "history_item_sample_id")
      <*> (o .:  "original_voice_id")
      <*> (o .:  "public_owner_id")
      <*> (o .:  "liked_by_count")
      <*> (o .:  "cloned_by_count")

-- | ToJSON VoiceSharingResponseModel
instance A.ToJSON VoiceSharingResponseModel where
  toJSON VoiceSharingResponseModel {..} =
   _omitNulls
      [ "status" .= voiceSharingResponseModelStatus
      , "history_item_sample_id" .= voiceSharingResponseModelHistoryItemSampleId
      , "original_voice_id" .= voiceSharingResponseModelOriginalVoiceId
      , "public_owner_id" .= voiceSharingResponseModelPublicOwnerId
      , "liked_by_count" .= voiceSharingResponseModelLikedByCount
      , "cloned_by_count" .= voiceSharingResponseModelClonedByCount
      ]


-- | Construct a value of type 'VoiceSharingResponseModel' (by applying it's required fields, if any)
mkVoiceSharingResponseModel
  :: Text -- ^ 'voiceSharingResponseModelStatus' 
  -> Text -- ^ 'voiceSharingResponseModelHistoryItemSampleId' 
  -> Text -- ^ 'voiceSharingResponseModelOriginalVoiceId' 
  -> Text -- ^ 'voiceSharingResponseModelPublicOwnerId' 
  -> Int -- ^ 'voiceSharingResponseModelLikedByCount' 
  -> Int -- ^ 'voiceSharingResponseModelClonedByCount' 
  -> VoiceSharingResponseModel
mkVoiceSharingResponseModel voiceSharingResponseModelStatus voiceSharingResponseModelHistoryItemSampleId voiceSharingResponseModelOriginalVoiceId voiceSharingResponseModelPublicOwnerId voiceSharingResponseModelLikedByCount voiceSharingResponseModelClonedByCount =
  VoiceSharingResponseModel
  { voiceSharingResponseModelStatus
  , voiceSharingResponseModelHistoryItemSampleId
  , voiceSharingResponseModelOriginalVoiceId
  , voiceSharingResponseModelPublicOwnerId
  , voiceSharingResponseModelLikedByCount
  , voiceSharingResponseModelClonedByCount
  }


-- * Enums


-- ** E'Currency

-- | Enum of 'Text'
data E'Currency
  = E'Currency'Usd -- ^ @"usd"@
  | E'Currency'Eur -- ^ @"eur"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Currency where toJSON = A.toJSON . fromE'Currency
instance A.FromJSON E'Currency where parseJSON o = P.either P.fail (pure . P.id) . toE'Currency =<< A.parseJSON o
instance WH.ToHttpApiData E'Currency where toQueryParam = WH.toQueryParam . fromE'Currency
instance WH.FromHttpApiData E'Currency where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Currency
instance MimeRender MimeMultipartFormData E'Currency where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Currency' enum
fromE'Currency :: E'Currency -> Text
fromE'Currency = \case
  E'Currency'Usd -> "usd"
  E'Currency'Eur -> "eur"

-- | parse 'E'Currency' enum
toE'Currency :: Text -> P.Either String E'Currency
toE'Currency = \case
  "usd" -> P.Right E'Currency'Usd
  "eur" -> P.Right E'Currency'Eur
  s -> P.Left $ "toE'Currency: enum parse failure: " P.++ P.show s


-- ** E'FinetuningState

-- | Enum of 'Text'
data E'FinetuningState
  = E'FinetuningState'Not_started -- ^ @"not_started"@
  | E'FinetuningState'Is_fine_tuning -- ^ @"is_fine_tuning"@
  | E'FinetuningState'Fine_tuned -- ^ @"fine_tuned"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FinetuningState where toJSON = A.toJSON . fromE'FinetuningState
instance A.FromJSON E'FinetuningState where parseJSON o = P.either P.fail (pure . P.id) . toE'FinetuningState =<< A.parseJSON o
instance WH.ToHttpApiData E'FinetuningState where toQueryParam = WH.toQueryParam . fromE'FinetuningState
instance WH.FromHttpApiData E'FinetuningState where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FinetuningState
instance MimeRender MimeMultipartFormData E'FinetuningState where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FinetuningState' enum
fromE'FinetuningState :: E'FinetuningState -> Text
fromE'FinetuningState = \case
  E'FinetuningState'Not_started -> "not_started"
  E'FinetuningState'Is_fine_tuning -> "is_fine_tuning"
  E'FinetuningState'Fine_tuned -> "fine_tuned"

-- | parse 'E'FinetuningState' enum
toE'FinetuningState :: Text -> P.Either String E'FinetuningState
toE'FinetuningState = \case
  "not_started" -> P.Right E'FinetuningState'Not_started
  "is_fine_tuning" -> P.Right E'FinetuningState'Is_fine_tuning
  "fine_tuned" -> P.Right E'FinetuningState'Fine_tuned
  s -> P.Left $ "toE'FinetuningState: enum parse failure: " P.++ P.show s


-- ** E'State

-- | Enum of 'Text'
data E'State
  = E'State'Created -- ^ @"created"@
  | E'State'Deleted -- ^ @"deleted"@
  | E'State'Processing -- ^ @"processing"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'Created -> "created"
  E'State'Deleted -> "deleted"
  E'State'Processing -> "processing"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "created" -> P.Right E'State'Created
  "deleted" -> P.Right E'State'Deleted
  "processing" -> P.Right E'State'Processing
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text'
data E'Status
  = E'Status'Trialing -- ^ @"trialing"@
  | E'Status'Active -- ^ @"active"@
  | E'Status'Incomplete -- ^ @"incomplete"@
  | E'Status'Incomplete_expired -- ^ @"incomplete_expired"@
  | E'Status'Past_due -- ^ @"past_due"@
  | E'Status'Canceled -- ^ @"canceled"@
  | E'Status'Unpaid -- ^ @"unpaid"@
  | E'Status'Free -- ^ @"free"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'Trialing -> "trialing"
  E'Status'Active -> "active"
  E'Status'Incomplete -> "incomplete"
  E'Status'Incomplete_expired -> "incomplete_expired"
  E'Status'Past_due -> "past_due"
  E'Status'Canceled -> "canceled"
  E'Status'Unpaid -> "unpaid"
  E'Status'Free -> "free"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "trialing" -> P.Right E'Status'Trialing
  "active" -> P.Right E'Status'Active
  "incomplete" -> P.Right E'Status'Incomplete
  "incomplete_expired" -> P.Right E'Status'Incomplete_expired
  "past_due" -> P.Right E'Status'Past_due
  "canceled" -> P.Right E'Status'Canceled
  "unpaid" -> P.Right E'Status'Unpaid
  "free" -> P.Right E'Status'Free
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s



